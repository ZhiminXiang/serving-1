package resources

import (
	"testing"

	"github.com/google/go-cmp/cmp"
	. "github.com/knative/pkg/logging/testing"
	"github.com/knative/serving/pkg/apis/networking"
	"github.com/knative/serving/pkg/apis/networking/v1alpha1"
	"github.com/knative/serving/pkg/reconciler/v1alpha1/clusteringress/config"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kubeinformers "k8s.io/client-go/informers"
	fakek8s "k8s.io/client-go/kubernetes/fake"
)

func TestMakeSecrets(t *testing.T) {
	kubeClient := fakek8s.NewSimpleClientset()
	secretClient := kubeinformers.NewSharedInformerFactory(kubeClient, 0).Core().V1().Secrets()
	createSecret := func(secret *corev1.Secret) {
		kubeClient.CoreV1().Secrets(secret.Namespace).Create(secret)
		secretClient.Informer().GetIndexer().Add(secret)
	}

	ctx := TestContextWithLogger(t)
	ctx = config.ToContext(ctx, &config.Config{
		Istio: &config.Istio{
			IngressGateways: []config.Gateway{{
				GatewayName: "test-gateway",
				// The namespace of Istio gateway service is istio-system.
				ServiceURL: "istio-ingressgateway.istio-system.svc.cluster.local",
			}},
		},
	})

	cases := []struct {
		name         string
		ci           *v1alpha1.ClusterIngress
		originSecret *corev1.Secret
		expected     []*corev1.Secret
		wantErr      bool
	}{{
		name: "target secret namespace is the same as the origin secret namespace.",
		ci: &v1alpha1.ClusterIngress{
			Spec: v1alpha1.IngressSpec{
				TLS: []v1alpha1.ClusterIngressTLS{{
					Hosts:           []string{"example.com"},
					SecretName:      "test-secret",
					SecretNamespace: "istio-system",
				}},
			}},
		originSecret: &corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "test-secret",
				Namespace: "istio-system",
			},
			Data: map[string][]byte{
				"test-data": []byte("abcd"),
			}},
		expected: []*corev1.Secret{},
		wantErr:  false,
	}, {
		name: "target secret namespace is different from the origin secret namespace.",
		ci: &v1alpha1.ClusterIngress{
			Spec: v1alpha1.IngressSpec{
				TLS: []v1alpha1.ClusterIngressTLS{{
					Hosts:           []string{"example.com"},
					SecretName:      "test-secret",
					SecretNamespace: "knative-serving",
				}},
			}},
		originSecret: &corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "test-secret",
				Namespace: "knative-serving",
			},
			Data: map[string][]byte{
				"test-data": []byte("abcd"),
			}},
		expected: []*corev1.Secret{{
			ObjectMeta: metav1.ObjectMeta{
				// Name is generated by TargetSecret function.
				Name: "knative-serving--test-secret",
				// Expected secret should be in istio-system which is
				// the ns of Istio gateway service.
				Namespace: "istio-system",
				Labels: map[string]string{
					networking.OriginSecretNameLabelKey:      "test-secret",
					networking.OriginSecretNamespaceLabelKey: "knative-serving",
				},
			},
			Data: map[string][]byte{
				"test-data": []byte("abcd"),
			},
		}},
		wantErr: false,
	}, {
		name: "fail to get origin secret",
		// There is no secret "knative-serving-1/test-secret-1. So erro will be thrown."
		ci: &v1alpha1.ClusterIngress{
			Spec: v1alpha1.IngressSpec{
				TLS: []v1alpha1.ClusterIngressTLS{{
					Hosts:           []string{"example.com"},
					SecretName:      "test-secret-1",
					SecretNamespace: "knative-serving-1",
				}},
			}},
		originSecret: &corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "no-exist-secret",
				Namespace: "no-exist-namespace",
			},
			Data: map[string][]byte{
				"test-data": []byte("abcd"),
			}},
		wantErr: true,
	}}
	for _, c := range cases {
		if c.originSecret != nil {
			createSecret(c.originSecret)
		}
		t.Run(c.name, func(t *testing.T) {
			secrets, err := MakeSecrets(ctx, c.ci, secretClient.Lister())
			if (err != nil) != c.wantErr {
				t.Fatalf("Test: %s; MakeDesiredSecrets error = %v, WantErr %v", c.name, err, c.wantErr)
			}
			if diff := cmp.Diff(c.expected, secrets); diff != "" {
				t.Errorf("Unexpected secrets (-want, +got): %v", diff)
			}
		})
	}
}
